# I2C Notes

- Requires two wires.
- Supports multiple parents, allowing each parent to talk to all the children on the bus, except other parents. 
- Parents must take turns using the bus line.

### Signals
- Two signals (SCL, SDA)
    - SCL: Clock Signal. 
        - Generated by the bus parent.
    - SDA: Data Signal
        - Requires a start and stop bit.
        - Two Frames:
            - Address frame indicating the child to which the message is being sent.
            - One or more data frames, which are 8-bt messages passed from parent to child or vise versa.
        - Start Condition:
            - Parent leave SCL high, pulls SDA low.
            - This places all children on notice.
        - Address Frame
            - Sends Most Significant Bit first.
            - Followed by R/W [(1) Read, (0) Write] bit, indicating the operation.
            - *Add stuff about NACK/ACK bit*
            - 


# NXP Documentation Notes
- Two wires carry information between the devices connected to the bus.
    - SDA (Serial Data)
    - SCL (Serial Clock)
    - Logic levels are set as:
        - '0' (LOW) = 0.3 V_DD [30%]
        - '1' (HIGH) = 0.7 V_DD [70%]
- The parent
    - Initiates the transfer
    - Generates the clock signal
    - Generates STOP / STOP conditions
- The child
    - Any device that is addressed
    - Can pause data transfer if necessary (such as due to an internal interrupt)
        - Sets SCL to LOW 
        - Forces parent into wait state
        - Transfer continues when child is ready
- Process
    - START (S) 
        - Begins transactions
        - HIGH to LOW on SDA WHILE SCL is HIGH
        - Bus is busy
    - STOP (P)
        - LOW to HIGH on SDA while SCL is HIGH 
        - Bus is free after a certain time [specified in documentation]
    - ACK / NACK
        - Acknowledge bit takes places after every byte
        - Allows the receiver to signal the transmitter that the byte was sucessfully received
        - Generated by parent
        - Acknowledge Signal Definition:
            1.  Transmitter releass the SDA line during ACK clock pulse.
            2. If reciever pulls the SDA line LOW, and remains low during the HIGH period of the clock pulse, it is an ACK bit.
            3. If SDA remains HIGH during the HIGH period of the clock pulse, it is a NACK bit.
            4. 5 conditions may lead to a NACK
                - No receiever present on the bus with the specified address
                - Receiver busy / not ready to start communication with parent.
                - During the transfer, receiver gets data it cannot understand.
                - During the transfer, receiver cannot receive any more data bytes.
                - A parent-receiver must signal the end of the transfer to the child-transmitter.

        - If a NACk occurs, the parent can decide to either generate a STOP condition to abort the transfer, or repeat a START condition to begin a new transfer.
    - CHILD ADDRESS and R/W Bit
        - After start condition, the 7 bit child address is sent followed by the read (1) / write (0) bit. 

# Reference Manual Notes

## Pins
```
I2C_SDA - i2c Data
I2C_SCL - i2c clock

```

# Function Definition Outline
1. i2c_start_transfer(child address, read / write bit, data)
2. i2c_stop_trasnfer (child address)
3. i2c_send_ack(child adress)
4. i2c_send_nack(child adress)
5. i2c_send_data(child adress, data)
6. i2c_request_data(child adress)

## Function Use Example
1 Parent

1 Child (Address: 000 0010)

Message: The integer 7 (000 0111)

Write Example

Call i2c_start_transfer(0000010, 0).

The above function's body:

```
i2c_start_transfer(child address, read / write bit, data)
{
    if(read / write bit == 0) #Write
        i2c_send_data(child address, data)

}
```




# How to use driver
1. Declare I2C_HaldTypeDef
```
I2C_HandleTypeDef hi2c;
```
2. Initialize the I2C low level resources
    1. Configure the HAL_I2C_MspInit() API:
    ```c
    hi2c1.Instance = I2C1;
	hi2c1.Init.Timing = 0x10707DBC;
	hi2c1.Init.OwnAddress1 = //I2C_ADDRESS;
	hi2c1.Init.AddressingMode = //I2C_ADDRESSINGMODE_7BIT;
	hi2c1.Init.DualAddressMode = //I2C_DUALADDRESS_DISABLE;
	hi2c1.Init.OwnAddress2 = //0;
	hi2c1.Init.OwnAddress2Masks = //I2C_OA2_NOMASK;
	hi2c1.Init.GeneralCallMode = //I2C_GENERALCALL_DISABLE;
	hi2c1.Init.NoStretchMode = //I2C_NOSTRETCH_DISABLE;
    ```
    2. Call HAL_I2C_Init() to configure the device
    ```
    HAL_I2C_Init(&hi2c1);
    ```
    
    
```

HAL_I2C_MspInit(hi2c);
```


# Variable
```
I2C_HandleTypeDef hi2c1;
```
# i2c_init(I2C_HandleTypeDef hi2c)
```
{
    hi2c.Instance = I2C1;
	hi2c.Init.Timing = 0x10707DBC;
	hi2c.Init.OwnAddress1 = I2C_ADDRESS;
	hi2c.Init.AddressingMode = I2C_ADDRESSINGMODE_7BIT;
	hi2c.Init.DualAddressMode = I2C_DUALADDRESS_DISABLE;
	hi2c.Init.OwnAddress2 = 0;
	hi2c.Init.OwnAddress2Masks = I2C_OA2_NOMASK;
	hi2c.Init.GeneralCallMode = I2C_GENERALCALL_DISABLE;
	hi2c.Init.NoStretchMode = I2C_NOSTRETCH_DISABLE;
}
```

    



